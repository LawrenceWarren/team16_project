{"ast":null,"code":"'use strict'; // module to handle cookies\n\nvar urllib = require('url');\n\nvar SESSION_TIMEOUT = 1800; // 30 min\n\nmodule.exports = Cookies;\n/**\n * Creates a biskviit cookie jar for managing cookie values in memory\n *\n * @constructor\n * @param {Object} [options] Optional options object\n */\n\nfunction Cookies(options) {\n  this.options = options || {};\n  this.cookies = [];\n}\n/**\n * Stores a cookie string to the cookie storage\n *\n * @param {String} cookieStr Value from the 'Set-Cookie:' header\n * @param {String} url Current URL\n */\n\n\nCookies.prototype.set = function (cookieStr, url) {\n  var urlparts = urllib.parse(url || '');\n  var cookie = this.parse(cookieStr);\n  var domain;\n\n  if (cookie.domain) {\n    domain = cookie.domain.replace(/^\\./, ''); // do not allow cross origin cookies\n\n    if ( // can't be valid if the requested domain is shorter than current hostname\n    urlparts.hostname.length < domain.length || // prefix domains with dot to be sure that partial matches are not used\n    ('.' + urlparts.hostname).substr(-domain.length + 1) !== '.' + domain) {\n      cookie.domain = urlparts.hostname;\n    }\n  } else {\n    cookie.domain = urlparts.hostname;\n  }\n\n  if (!cookie.path) {\n    cookie.path = this.getPath(urlparts.pathname);\n  } // if no expire date, then use sessionTimeout value\n\n\n  if (!cookie.expires) {\n    cookie.expires = new Date(Date.now() + (Number(this.options.sessionTimeout || SESSION_TIMEOUT) || SESSION_TIMEOUT) * 1000);\n  }\n\n  return this.add(cookie);\n};\n/**\n * Returns cookie string for the 'Cookie:' header.\n *\n * @param {String} url URL to check for\n * @returns {String} Cookie header or empty string if no matches were found\n */\n\n\nCookies.prototype.get = function (url) {\n  return this.list(url).map(function (cookie) {\n    return cookie.name + '=' + cookie.value;\n  }).join('; ');\n};\n/**\n * Lists all valied cookie objects for the specified URL\n *\n * @param {String} url URL to check for\n * @returns {Array} An array of cookie objects\n */\n\n\nCookies.prototype.list = function (url) {\n  var result = [];\n  var i;\n  var cookie;\n\n  for (i = this.cookies.length - 1; i >= 0; i--) {\n    cookie = this.cookies[i];\n\n    if (this.isExpired(cookie)) {\n      this.cookies.splice(i, i);\n      continue;\n    }\n\n    if (this.match(cookie, url)) {\n      result.unshift(cookie);\n    }\n  }\n\n  return result;\n};\n/**\n * Parses cookie string from the 'Set-Cookie:' header\n *\n * @param {String} cookieStr String from the 'Set-Cookie:' header\n * @returns {Object} Cookie object\n */\n\n\nCookies.prototype.parse = function (cookieStr) {\n  var cookie = {};\n  (cookieStr || '').toString().split(';').forEach(function (cookiePart) {\n    var valueParts = cookiePart.split('=');\n    var key = valueParts.shift().trim().toLowerCase();\n    var value = valueParts.join('=').trim();\n    var domain;\n\n    if (!key) {\n      // skip empty parts\n      return;\n    }\n\n    switch (key) {\n      case 'expires':\n        value = new Date(value); // ignore date if can not parse it\n\n        if (value.toString() !== 'Invalid Date') {\n          cookie.expires = value;\n        }\n\n        break;\n\n      case 'path':\n        cookie.path = value;\n        break;\n\n      case 'domain':\n        domain = value.toLowerCase();\n\n        if (domain.length && domain.charAt(0) !== '.') {\n          domain = '.' + domain; // ensure preceeding dot for user set domains\n        }\n\n        cookie.domain = domain;\n        break;\n\n      case 'max-age':\n        cookie.expires = new Date(Date.now() + (Number(value) || 0) * 1000);\n        break;\n\n      case 'secure':\n        cookie.secure = true;\n        break;\n\n      case 'httponly':\n        cookie.httponly = true;\n        break;\n\n      default:\n        if (!cookie.name) {\n          cookie.name = key;\n          cookie.value = value;\n        }\n\n    }\n  });\n  return cookie;\n};\n/**\n * Checks if a cookie object is valid for a specified URL\n *\n * @param {Object} cookie Cookie object\n * @param {String} url URL to check for\n * @returns {Boolean} true if cookie is valid for specifiec URL\n */\n\n\nCookies.prototype.match = function (cookie, url) {\n  var urlparts = urllib.parse(url || ''); // check if hostname matches\n  // .foo.com also matches subdomains, foo.com does not\n\n  if (urlparts.hostname !== cookie.domain && (cookie.domain.charAt(0) !== '.' || ('.' + urlparts.hostname).substr(-cookie.domain.length) !== cookie.domain)) {\n    return false;\n  } // check if path matches\n\n\n  var path = this.getPath(urlparts.pathname);\n\n  if (path.substr(0, cookie.path.length) !== cookie.path) {\n    return false;\n  } // check secure argument\n\n\n  if (cookie.secure && urlparts.protocol !== 'https:') {\n    return false;\n  }\n\n  return true;\n};\n/**\n * Adds (or updates/removes if needed) a cookie object to the cookie storage\n *\n * @param {Object} cookie Cookie value to be stored\n */\n\n\nCookies.prototype.add = function (cookie) {\n  var i;\n  var len; // nothing to do here\n\n  if (!cookie || !cookie.name) {\n    return false;\n  } // overwrite if has same params\n\n\n  for (i = 0, len = this.cookies.length; i < len; i++) {\n    if (this.compare(this.cookies[i], cookie)) {\n      // check if the cookie needs to be removed instead\n      if (this.isExpired(cookie)) {\n        this.cookies.splice(i, 1); // remove expired/unset cookie\n\n        return false;\n      }\n\n      this.cookies[i] = cookie;\n      return true;\n    }\n  } // add as new if not already expired\n\n\n  if (!this.isExpired(cookie)) {\n    this.cookies.push(cookie);\n  }\n\n  return true;\n};\n/**\n * Checks if two cookie objects are the same\n *\n * @param {Object} a Cookie to check against\n * @param {Object} b Cookie to check against\n * @returns {Boolean} True, if the cookies are the same\n */\n\n\nCookies.prototype.compare = function (a, b) {\n  return a.name === b.name && a.path === b.path && a.domain === b.domain && a.secure === b.secure && a.httponly === a.httponly;\n};\n/**\n * Checks if a cookie is expired\n *\n * @param {Object} cookie Cookie object to check against\n * @returns {Boolean} True, if the cookie is expired\n */\n\n\nCookies.prototype.isExpired = function (cookie) {\n  return cookie.expires && cookie.expires < new Date() || !cookie.value;\n};\n/**\n * Returns normalized cookie path for an URL path argument\n *\n * @param {String} pathname\n * @returns {String} Normalized path\n */\n\n\nCookies.prototype.getPath = function (pathname) {\n  var path = (pathname || '/').split('/');\n  path.pop(); // remove filename part\n\n  path = path.join('/').trim(); // ensure path prefix /\n\n  if (path.charAt(0) !== '/') {\n    path = '/' + path;\n  } // ensure path suffix /\n\n\n  if (path.substr(-1) !== '/') {\n    path += '/';\n  }\n\n  return path;\n};","map":{"version":3,"sources":["C:/Users/Administrator/Desktop/GRP/frontend/node_modules/nodemailer-fetch/lib/cookies.js"],"names":["urllib","require","SESSION_TIMEOUT","module","exports","Cookies","options","cookies","prototype","set","cookieStr","url","urlparts","parse","cookie","domain","replace","hostname","length","substr","path","getPath","pathname","expires","Date","now","Number","sessionTimeout","add","get","list","map","name","value","join","result","i","isExpired","splice","match","unshift","toString","split","forEach","cookiePart","valueParts","key","shift","trim","toLowerCase","charAt","secure","httponly","protocol","len","compare","push","a","b","pop"],"mappings":"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","sourcesContent":["'use strict';\n\n// module to handle cookies\n\nvar urllib = require('url');\n\nvar SESSION_TIMEOUT = 1800; // 30 min\n\nmodule.exports = Cookies;\n\n/**\n * Creates a biskviit cookie jar for managing cookie values in memory\n *\n * @constructor\n * @param {Object} [options] Optional options object\n */\nfunction Cookies(options) {\n    this.options = options || {};\n    this.cookies = [];\n}\n\n/**\n * Stores a cookie string to the cookie storage\n *\n * @param {String} cookieStr Value from the 'Set-Cookie:' header\n * @param {String} url Current URL\n */\nCookies.prototype.set = function (cookieStr, url) {\n    var urlparts = urllib.parse(url || '');\n    var cookie = this.parse(cookieStr);\n    var domain;\n\n    if (cookie.domain) {\n        domain = cookie.domain.replace(/^\\./, '');\n\n        // do not allow cross origin cookies\n        if (\n            // can't be valid if the requested domain is shorter than current hostname\n            urlparts.hostname.length < domain.length ||\n\n            // prefix domains with dot to be sure that partial matches are not used\n            ('.' + urlparts.hostname).substr(-domain.length + 1) !== ('.' + domain)) {\n            cookie.domain = urlparts.hostname;\n        }\n    } else {\n        cookie.domain = urlparts.hostname;\n    }\n\n    if (!cookie.path) {\n        cookie.path = this.getPath(urlparts.pathname);\n    }\n\n    // if no expire date, then use sessionTimeout value\n    if (!cookie.expires) {\n        cookie.expires = new Date(Date.now() + (Number(this.options.sessionTimeout || SESSION_TIMEOUT) || SESSION_TIMEOUT) * 1000);\n    }\n\n    return this.add(cookie);\n};\n\n/**\n * Returns cookie string for the 'Cookie:' header.\n *\n * @param {String} url URL to check for\n * @returns {String} Cookie header or empty string if no matches were found\n */\nCookies.prototype.get = function (url) {\n    return this.list(url).map(function (cookie) {\n        return cookie.name + '=' + cookie.value;\n    }).join('; ');\n};\n\n/**\n * Lists all valied cookie objects for the specified URL\n *\n * @param {String} url URL to check for\n * @returns {Array} An array of cookie objects\n */\nCookies.prototype.list = function (url) {\n    var result = [];\n    var i;\n    var cookie;\n\n    for (i = this.cookies.length - 1; i >= 0; i--) {\n        cookie = this.cookies[i];\n\n        if (this.isExpired(cookie)) {\n            this.cookies.splice(i, i);\n            continue;\n        }\n\n        if (this.match(cookie, url)) {\n            result.unshift(cookie);\n        }\n    }\n\n    return result;\n};\n\n/**\n * Parses cookie string from the 'Set-Cookie:' header\n *\n * @param {String} cookieStr String from the 'Set-Cookie:' header\n * @returns {Object} Cookie object\n */\nCookies.prototype.parse = function (cookieStr) {\n    var cookie = {};\n\n    (cookieStr || '').toString().split(';').forEach(function (cookiePart) {\n        var valueParts = cookiePart.split('=');\n        var key = valueParts.shift().trim().toLowerCase();\n        var value = valueParts.join('=').trim();\n        var domain;\n\n        if (!key) {\n            // skip empty parts\n            return;\n        }\n\n        switch (key) {\n\n            case 'expires':\n                value = new Date(value);\n                // ignore date if can not parse it\n                if (value.toString() !== 'Invalid Date') {\n                    cookie.expires = value;\n                }\n                break;\n\n            case 'path':\n                cookie.path = value;\n                break;\n\n            case 'domain':\n                domain = value.toLowerCase();\n                if (domain.length && domain.charAt(0) !== '.') {\n                    domain = '.' + domain; // ensure preceeding dot for user set domains\n                }\n                cookie.domain = domain;\n                break;\n\n            case 'max-age':\n                cookie.expires = new Date(Date.now() + (Number(value) || 0) * 1000);\n                break;\n\n            case 'secure':\n                cookie.secure = true;\n                break;\n\n            case 'httponly':\n                cookie.httponly = true;\n                break;\n\n            default:\n                if (!cookie.name) {\n                    cookie.name = key;\n                    cookie.value = value;\n                }\n        }\n    });\n\n    return cookie;\n};\n\n/**\n * Checks if a cookie object is valid for a specified URL\n *\n * @param {Object} cookie Cookie object\n * @param {String} url URL to check for\n * @returns {Boolean} true if cookie is valid for specifiec URL\n */\nCookies.prototype.match = function (cookie, url) {\n    var urlparts = urllib.parse(url || '');\n\n    // check if hostname matches\n    // .foo.com also matches subdomains, foo.com does not\n    if (urlparts.hostname !== cookie.domain && (cookie.domain.charAt(0) !== '.' || ('.' + urlparts.hostname).substr(-cookie.domain.length) !== cookie.domain)) {\n        return false;\n    }\n\n    // check if path matches\n    var path = this.getPath(urlparts.pathname);\n    if (path.substr(0, cookie.path.length) !== cookie.path) {\n        return false;\n    }\n\n    // check secure argument\n    if (cookie.secure && urlparts.protocol !== 'https:') {\n        return false;\n    }\n\n    return true;\n};\n\n/**\n * Adds (or updates/removes if needed) a cookie object to the cookie storage\n *\n * @param {Object} cookie Cookie value to be stored\n */\nCookies.prototype.add = function (cookie) {\n    var i;\n    var len;\n\n    // nothing to do here\n    if (!cookie || !cookie.name) {\n        return false;\n    }\n\n    // overwrite if has same params\n    for (i = 0, len = this.cookies.length; i < len; i++) {\n        if (this.compare(this.cookies[i], cookie)) {\n\n            // check if the cookie needs to be removed instead\n            if (this.isExpired(cookie)) {\n                this.cookies.splice(i, 1); // remove expired/unset cookie\n                return false;\n            }\n\n            this.cookies[i] = cookie;\n            return true;\n        }\n    }\n\n    // add as new if not already expired\n    if (!this.isExpired(cookie)) {\n        this.cookies.push(cookie);\n    }\n\n    return true;\n};\n\n/**\n * Checks if two cookie objects are the same\n *\n * @param {Object} a Cookie to check against\n * @param {Object} b Cookie to check against\n * @returns {Boolean} True, if the cookies are the same\n */\nCookies.prototype.compare = function (a, b) {\n    return a.name === b.name && a.path === b.path && a.domain === b.domain && a.secure === b.secure && a.httponly === a.httponly;\n};\n\n/**\n * Checks if a cookie is expired\n *\n * @param {Object} cookie Cookie object to check against\n * @returns {Boolean} True, if the cookie is expired\n */\nCookies.prototype.isExpired = function (cookie) {\n    return (cookie.expires && cookie.expires < new Date()) || !cookie.value;\n};\n\n/**\n * Returns normalized cookie path for an URL path argument\n *\n * @param {String} pathname\n * @returns {String} Normalized path\n */\nCookies.prototype.getPath = function (pathname) {\n    var path = (pathname || '/').split('/');\n    path.pop(); // remove filename part\n    path = path.join('/').trim();\n\n    // ensure path prefix /\n    if (path.charAt(0) !== '/') {\n        path = '/' + path;\n    }\n\n    // ensure path suffix /\n    if (path.substr(-1) !== '/') {\n        path += '/';\n    }\n\n    return path;\n};\n"]},"metadata":{},"sourceType":"script"}