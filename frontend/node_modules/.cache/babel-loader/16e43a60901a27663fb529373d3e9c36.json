{"ast":null,"code":"'use strict';\n\nvar SMTPConnection = require('smtp-connection');\n\nvar packageData = require('../package.json');\n\nvar wellknown = require('nodemailer-wellknown');\n\nvar shared = require('nodemailer-shared');\n\nvar EventEmitter = require('events').EventEmitter;\n\nvar util = require('util'); // expose to the world\n\n\nmodule.exports = function (options) {\n  return new SMTPTransport(options);\n};\n/**\n * Creates a SMTP transport object for Nodemailer\n *\n * @constructor\n * @param {Object} options Connection options\n */\n\n\nfunction SMTPTransport(options) {\n  EventEmitter.call(this);\n  options = options || {};\n\n  if (typeof options === 'string') {\n    options = {\n      url: options\n    };\n  }\n\n  var urlData;\n  var service = options.service;\n\n  if (typeof options.getSocket === 'function') {\n    this.getSocket = options.getSocket;\n  }\n\n  if (options.url) {\n    urlData = shared.parseConnectionUrl(options.url);\n    service = service || urlData.service;\n  }\n\n  this.options = assign(false, // create new object\n  options, // regular options\n  urlData, // url options\n  service && wellknown(service) // wellknown options\n  );\n  this.logger = shared.getLogger(this.options); // temporary object\n\n  var connection = new SMTPConnection(this.options);\n  this.name = 'SMTP';\n  this.version = packageData.version + '[client:' + connection.version + ']';\n}\n\nutil.inherits(SMTPTransport, EventEmitter);\n/**\n * Placeholder function for creating proxy sockets. This method immediatelly returns\n * without a socket\n *\n * @param {Object} options Connection options\n * @param {Function} callback Callback function to run with the socket keys\n */\n\nSMTPTransport.prototype.getSocket = function (options, callback) {\n  // return immediatelly\n  return callback(null, false);\n};\n/**\n * Sends an e-mail using the selected settings\n *\n * @param {Object} mail Mail object\n * @param {Function} callback Callback function\n */\n\n\nSMTPTransport.prototype.send = function (mail, callback) {\n  this.getSocket(this.options, function (err, socketOptions) {\n    if (err) {\n      return callback(err);\n    }\n\n    var options = this.options;\n\n    if (socketOptions && socketOptions.connection) {\n      this.logger.info('Using proxied socket from %s:%s to %s:%s', socketOptions.connection.remoteAddress, socketOptions.connection.remotePort, options.host || '', options.port || ''); // only copy options if we need to modify it\n\n      options = assign(false, options);\n      Object.keys(socketOptions).forEach(function (key) {\n        options[key] = socketOptions[key];\n      });\n    }\n\n    var connection = new SMTPConnection(options);\n    var returned = false;\n    connection.once('error', function (err) {\n      if (returned) {\n        return;\n      }\n\n      returned = true;\n      connection.close();\n      return callback(err);\n    });\n    connection.once('end', function () {\n      if (returned) {\n        return;\n      }\n\n      returned = true;\n      return callback(new Error('Connection closed'));\n    });\n\n    var sendMessage = function () {\n      var envelope = mail.message.getEnvelope();\n      var messageId = (mail.message.getHeader('message-id') || '').replace(/[<>\\s]/g, '');\n      var recipients = [].concat(envelope.to || []);\n\n      if (recipients.length > 3) {\n        recipients.push('...and ' + recipients.splice(2).length + ' more');\n      }\n\n      this.logger.info('Sending message <%s> to <%s>', messageId, recipients.join(', '));\n      connection.send(envelope, mail.message.createReadStream(), function (err, info) {\n        if (returned) {\n          return;\n        }\n\n        returned = true;\n        connection.close();\n\n        if (err) {\n          return callback(err);\n        }\n\n        info.envelope = {\n          from: envelope.from,\n          to: envelope.to\n        };\n        info.messageId = messageId;\n        return callback(null, info);\n      });\n    }.bind(this);\n\n    connection.connect(function () {\n      if (returned) {\n        return;\n      }\n\n      if (this.options.auth) {\n        connection.login(this.options.auth, function (err) {\n          if (returned) {\n            return;\n          }\n\n          if (err) {\n            returned = true;\n            connection.close();\n            return callback(err);\n          }\n\n          sendMessage();\n        });\n      } else {\n        sendMessage();\n      }\n    }.bind(this));\n  }.bind(this));\n};\n/**\n * Verifies SMTP configuration\n *\n * @param {Function} callback Callback function\n */\n\n\nSMTPTransport.prototype.verify = function (callback) {\n  var promise;\n\n  if (!callback && typeof Promise === 'function') {\n    promise = new Promise(function (resolve, reject) {\n      callback = shared.callbackPromise(resolve, reject);\n    });\n  }\n\n  this.getSocket(this.options, function (err, socketOptions) {\n    if (err) {\n      return callback(err);\n    }\n\n    var options = this.options;\n\n    if (socketOptions && socketOptions.connection) {\n      this.logger.info('Using proxied socket from %s:%s', socketOptions.connection.remoteAddress, socketOptions.connection.remotePort);\n      options = assign(false, options);\n      Object.keys(socketOptions).forEach(function (key) {\n        options[key] = socketOptions[key];\n      });\n    }\n\n    var connection = new SMTPConnection(options);\n    var returned = false;\n    connection.once('error', function (err) {\n      if (returned) {\n        return;\n      }\n\n      returned = true;\n      connection.close();\n      return callback(err);\n    });\n    connection.once('end', function () {\n      if (returned) {\n        return;\n      }\n\n      returned = true;\n      return callback(new Error('Connection closed'));\n    });\n\n    var finalize = function () {\n      if (returned) {\n        return;\n      }\n\n      returned = true;\n      connection.quit();\n      return callback(null, true);\n    };\n\n    connection.connect(function () {\n      if (returned) {\n        return;\n      }\n\n      if (this.options.auth) {\n        connection.login(this.options.auth, function (err) {\n          if (returned) {\n            return;\n          }\n\n          if (err) {\n            returned = true;\n            connection.close();\n            return callback(err);\n          }\n\n          finalize();\n        });\n      } else {\n        finalize();\n      }\n    }.bind(this));\n  }.bind(this));\n  return promise;\n};\n/**\n * Copies properties from source objects to target objects\n */\n\n\nfunction assign()\n/* target, ... sources */\n{\n  var args = Array.prototype.slice.call(arguments);\n  var target = args.shift() || {};\n  args.forEach(function (source) {\n    Object.keys(source || {}).forEach(function (key) {\n      if (['tls', 'auth'].indexOf(key) >= 0 && source[key] && typeof source[key] === 'object') {\n        // tls and auth are special keys that need to be enumerated separately\n        // other objects are passed as is\n        if (!target[key]) {\n          // esnure that target has this key\n          target[key] = {};\n        }\n\n        Object.keys(source[key]).forEach(function (subKey) {\n          target[key][subKey] = source[key][subKey];\n        });\n      } else {\n        target[key] = source[key];\n      }\n    });\n  });\n  return target;\n}","map":{"version":3,"sources":["C:/Users/Administrator/Desktop/GRP/frontend/node_modules/nodemailer-smtp-transport/lib/smtp-transport.js"],"names":["SMTPConnection","require","packageData","wellknown","shared","EventEmitter","util","module","exports","options","SMTPTransport","call","url","urlData","service","getSocket","parseConnectionUrl","assign","logger","getLogger","connection","name","version","inherits","prototype","callback","send","mail","err","socketOptions","info","remoteAddress","remotePort","host","port","Object","keys","forEach","key","returned","once","close","Error","sendMessage","envelope","message","getEnvelope","messageId","getHeader","replace","recipients","concat","to","length","push","splice","join","createReadStream","from","bind","connect","auth","login","verify","promise","Promise","resolve","reject","callbackPromise","finalize","quit","args","Array","slice","arguments","target","shift","source","indexOf","subKey"],"mappings":"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","sourcesContent":["'use strict';\n\nvar SMTPConnection = require('smtp-connection');\nvar packageData = require('../package.json');\nvar wellknown = require('nodemailer-wellknown');\nvar shared = require('nodemailer-shared');\n\nvar EventEmitter = require('events').EventEmitter;\nvar util = require('util');\n\n// expose to the world\nmodule.exports = function (options) {\n    return new SMTPTransport(options);\n};\n\n/**\n * Creates a SMTP transport object for Nodemailer\n *\n * @constructor\n * @param {Object} options Connection options\n */\nfunction SMTPTransport(options) {\n    EventEmitter.call(this);\n\n    options = options || {};\n    if (typeof options === 'string') {\n        options = {\n            url: options\n        };\n    }\n\n    var urlData;\n    var service = options.service;\n\n    if (typeof options.getSocket === 'function') {\n        this.getSocket = options.getSocket;\n    }\n\n    if (options.url) {\n        urlData = shared.parseConnectionUrl(options.url);\n        service = service || urlData.service;\n    }\n\n    this.options = assign(\n        false, // create new object\n        options, // regular options\n        urlData, // url options\n        service && wellknown(service) // wellknown options\n    );\n\n    this.logger = shared.getLogger(this.options);\n\n    // temporary object\n    var connection = new SMTPConnection(this.options);\n\n    this.name = 'SMTP';\n    this.version = packageData.version + '[client:' + connection.version + ']';\n}\nutil.inherits(SMTPTransport, EventEmitter);\n\n/**\n * Placeholder function for creating proxy sockets. This method immediatelly returns\n * without a socket\n *\n * @param {Object} options Connection options\n * @param {Function} callback Callback function to run with the socket keys\n */\nSMTPTransport.prototype.getSocket = function (options, callback) {\n    // return immediatelly\n    return callback(null, false);\n};\n\n/**\n * Sends an e-mail using the selected settings\n *\n * @param {Object} mail Mail object\n * @param {Function} callback Callback function\n */\nSMTPTransport.prototype.send = function (mail, callback) {\n\n    this.getSocket(this.options, function (err, socketOptions) {\n        if (err) {\n            return callback(err);\n        }\n\n        var options = this.options;\n        if (socketOptions && socketOptions.connection) {\n            this.logger.info('Using proxied socket from %s:%s to %s:%s', socketOptions.connection.remoteAddress, socketOptions.connection.remotePort, options.host || '', options.port || '');\n            // only copy options if we need to modify it\n            options = assign(false, options);\n            Object.keys(socketOptions).forEach(function (key) {\n                options[key] = socketOptions[key];\n            });\n        }\n\n        var connection = new SMTPConnection(options);\n        var returned = false;\n\n        connection.once('error', function (err) {\n            if (returned) {\n                return;\n            }\n            returned = true;\n            connection.close();\n            return callback(err);\n        });\n\n        connection.once('end', function () {\n            if (returned) {\n                return;\n            }\n            returned = true;\n            return callback(new Error('Connection closed'));\n        });\n\n        var sendMessage = function () {\n            var envelope = mail.message.getEnvelope();\n            var messageId = (mail.message.getHeader('message-id') || '').replace(/[<>\\s]/g, '');\n            var recipients = [].concat(envelope.to || []);\n            if (recipients.length > 3) {\n                recipients.push('...and ' + recipients.splice(2).length + ' more');\n            }\n\n            this.logger.info('Sending message <%s> to <%s>', messageId, recipients.join(', '));\n\n            connection.send(envelope, mail.message.createReadStream(), function (err, info) {\n                if (returned) {\n                    return;\n                }\n                returned = true;\n\n                connection.close();\n                if (err) {\n                    return callback(err);\n                }\n                info.envelope = {\n                    from: envelope.from,\n                    to: envelope.to\n                };\n                info.messageId = messageId;\n                return callback(null, info);\n            });\n        }.bind(this);\n\n        connection.connect(function () {\n            if (returned) {\n                return;\n            }\n\n            if (this.options.auth) {\n                connection.login(this.options.auth, function (err) {\n                    if (returned) {\n                        return;\n                    }\n\n                    if (err) {\n                        returned = true;\n                        connection.close();\n                        return callback(err);\n                    }\n\n                    sendMessage();\n                });\n            } else {\n                sendMessage();\n            }\n        }.bind(this));\n    }.bind(this));\n};\n\n/**\n * Verifies SMTP configuration\n *\n * @param {Function} callback Callback function\n */\nSMTPTransport.prototype.verify = function (callback) {\n    var promise;\n\n    if (!callback && typeof Promise === 'function') {\n        promise = new Promise(function (resolve, reject) {\n            callback = shared.callbackPromise(resolve, reject);\n        });\n    }\n\n    this.getSocket(this.options, function (err, socketOptions) {\n        if (err) {\n            return callback(err);\n        }\n\n        var options = this.options;\n        if (socketOptions && socketOptions.connection) {\n            this.logger.info('Using proxied socket from %s:%s', socketOptions.connection.remoteAddress, socketOptions.connection.remotePort);\n            options = assign(false, options);\n            Object.keys(socketOptions).forEach(function (key) {\n                options[key] = socketOptions[key];\n            });\n        }\n\n        var connection = new SMTPConnection(options);\n        var returned = false;\n\n        connection.once('error', function (err) {\n            if (returned) {\n                return;\n            }\n            returned = true;\n            connection.close();\n            return callback(err);\n        });\n\n        connection.once('end', function () {\n            if (returned) {\n                return;\n            }\n            returned = true;\n            return callback(new Error('Connection closed'));\n        });\n\n        var finalize = function () {\n            if (returned) {\n                return;\n            }\n            returned = true;\n            connection.quit();\n            return callback(null, true);\n        };\n\n        connection.connect(function () {\n            if (returned) {\n                return;\n            }\n\n            if (this.options.auth) {\n                connection.login(this.options.auth, function (err) {\n                    if (returned) {\n                        return;\n                    }\n\n                    if (err) {\n                        returned = true;\n                        connection.close();\n                        return callback(err);\n                    }\n\n                    finalize();\n                });\n            } else {\n                finalize();\n            }\n        }.bind(this));\n    }.bind(this));\n\n    return promise;\n};\n\n/**\n * Copies properties from source objects to target objects\n */\nfunction assign( /* target, ... sources */ ) {\n    var args = Array.prototype.slice.call(arguments);\n    var target = args.shift() || {};\n\n    args.forEach(function (source) {\n        Object.keys(source || {}).forEach(function (key) {\n            if (['tls', 'auth'].indexOf(key) >= 0 && source[key] && typeof source[key] === 'object') {\n                // tls and auth are special keys that need to be enumerated separately\n                // other objects are passed as is\n                if (!target[key]) {\n                    // esnure that target has this key\n                    target[key] = {};\n                }\n                Object.keys(source[key]).forEach(function (subKey) {\n                    target[key][subKey] = source[key][subKey];\n                });\n            } else {\n                target[key] = source[key];\n            }\n        });\n    });\n    return target;\n}\n"]},"metadata":{},"sourceType":"script"}