{"ast":null,"code":"'use strict';\n\nvar stream = require('stream');\n\nvar Transform = stream.Transform;\n\nvar util = require('util');\n\nmodule.exports = DataStream;\n/**\n * Escapes dots in the beginning of lines. Ends the stream with <CR><LF>.<CR><LF>\n * Also makes sure that only <CR><LF> sequences are used for linebreaks\n *\n * @param {Object} options Stream options\n */\n\nfunction DataStream(options) {\n  // init Transform\n  this.options = options || {};\n  this._curLine = '';\n  this.inByteCount = 0;\n  this.outByteCount = 0;\n  this.lastByte = false;\n  Transform.call(this, this.options);\n}\n\nutil.inherits(DataStream, Transform);\n/**\n * Escapes dots\n */\n\nDataStream.prototype._transform = function (chunk, encoding, done) {\n  var chunks = [];\n  var chunklen = 0;\n  var i,\n      len,\n      lastPos = 0;\n  var buf;\n\n  if (!chunk || !chunk.length) {\n    return done();\n  }\n\n  if (typeof chunk === 'string') {\n    chunk = new Buffer(chunk);\n  }\n\n  this.inByteCount += chunk.length;\n\n  for (i = 0, len = chunk.length; i < len; i++) {\n    if (chunk[i] === 0x2E) {\n      // .\n      if (i && chunk[i - 1] === 0x0A || !i && (!this.lastByte || this.lastByte === 0x0A)) {\n        buf = chunk.slice(lastPos, i + 1);\n        chunks.push(buf);\n        chunks.push(new Buffer('.'));\n        chunklen += buf.length + 1;\n        lastPos = i + 1;\n      }\n    } else if (chunk[i] === 0x0A) {\n      // .\n      if (i && chunk[i - 1] !== 0x0D || !i && this.lastByte !== 0x0D) {\n        if (i > lastPos) {\n          buf = chunk.slice(lastPos, i);\n          chunks.push(buf);\n          chunklen += buf.length + 2;\n        } else {\n          chunklen += 2;\n        }\n\n        chunks.push(new Buffer('\\r\\n'));\n        lastPos = i + 1;\n      }\n    }\n  }\n\n  if (chunklen) {\n    // add last piece\n    if (lastPos < chunk.length) {\n      buf = chunk.slice(lastPos);\n      chunks.push(buf);\n      chunklen += buf.length;\n    }\n\n    this.outByteCount += chunklen;\n    this.push(Buffer.concat(chunks, chunklen));\n  } else {\n    this.outByteCount += chunk.length;\n    this.push(chunk);\n  }\n\n  this.lastByte = chunk[chunk.length - 1];\n  done();\n};\n/**\n * Finalizes the stream with a dot on a single line\n */\n\n\nDataStream.prototype._flush = function (done) {\n  var buf;\n\n  if (this.lastByte === 0x0A) {\n    buf = new Buffer('.\\r\\n');\n  } else if (this.lastByte === 0x0D) {\n    buf = new Buffer('\\n.\\r\\n');\n  } else {\n    buf = new Buffer('\\r\\n.\\r\\n');\n  }\n\n  this.outByteCount += buf.length;\n  this.push(buf);\n  done();\n};","map":{"version":3,"sources":["C:/Users/Administrator/Desktop/GRP/frontend/node_modules/smtp-connection/lib/data-stream.js"],"names":["stream","require","Transform","util","module","exports","DataStream","options","_curLine","inByteCount","outByteCount","lastByte","call","inherits","prototype","_transform","chunk","encoding","done","chunks","chunklen","i","len","lastPos","buf","length","Buffer","slice","push","concat","_flush"],"mappings":"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","sourcesContent":["'use strict';\n\nvar stream = require('stream');\nvar Transform = stream.Transform;\nvar util = require('util');\n\nmodule.exports = DataStream;\n\n/**\n * Escapes dots in the beginning of lines. Ends the stream with <CR><LF>.<CR><LF>\n * Also makes sure that only <CR><LF> sequences are used for linebreaks\n *\n * @param {Object} options Stream options\n */\nfunction DataStream(options) {\n    // init Transform\n    this.options = options || {};\n    this._curLine = '';\n\n    this.inByteCount = 0;\n    this.outByteCount = 0;\n    this.lastByte = false;\n\n    Transform.call(this, this.options);\n}\nutil.inherits(DataStream, Transform);\n\n/**\n * Escapes dots\n */\nDataStream.prototype._transform = function (chunk, encoding, done) {\n    var chunks = [];\n    var chunklen = 0;\n    var i, len, lastPos = 0;\n    var buf;\n\n    if (!chunk || !chunk.length) {\n        return done();\n    }\n\n    if (typeof chunk === 'string') {\n        chunk = new Buffer(chunk);\n    }\n\n    this.inByteCount += chunk.length;\n\n    for (i = 0, len = chunk.length; i < len; i++) {\n        if (chunk[i] === 0x2E) { // .\n            if (\n                (i && chunk[i - 1] === 0x0A) ||\n                (!i && (!this.lastByte || this.lastByte === 0x0A))\n            ) {\n                buf = chunk.slice(lastPos, i + 1);\n                chunks.push(buf);\n                chunks.push(new Buffer('.'));\n                chunklen += buf.length + 1;\n                lastPos = i + 1;\n            }\n        } else if (chunk[i] === 0x0A) { // .\n            if (\n                (i && chunk[i - 1] !== 0x0D) ||\n                (!i && this.lastByte !== 0x0D)\n            ) {\n                if (i > lastPos) {\n                    buf = chunk.slice(lastPos, i);\n                    chunks.push(buf);\n                    chunklen += buf.length + 2;\n                } else {\n                    chunklen += 2;\n                }\n                chunks.push(new Buffer('\\r\\n'));\n                lastPos = i + 1;\n            }\n        }\n    }\n\n    if (chunklen) {\n        // add last piece\n        if (lastPos < chunk.length) {\n            buf = chunk.slice(lastPos);\n            chunks.push(buf);\n            chunklen += buf.length;\n        }\n\n        this.outByteCount += chunklen;\n        this.push(Buffer.concat(chunks, chunklen));\n    } else {\n        this.outByteCount += chunk.length;\n        this.push(chunk);\n    }\n\n    this.lastByte = chunk[chunk.length - 1];\n    done();\n};\n\n/**\n * Finalizes the stream with a dot on a single line\n */\nDataStream.prototype._flush = function (done) {\n    var buf;\n    if (this.lastByte === 0x0A) {\n        buf = new Buffer('.\\r\\n');\n    } else if (this.lastByte === 0x0D) {\n        buf = new Buffer('\\n.\\r\\n');\n    } else {\n        buf = new Buffer('\\r\\n.\\r\\n');\n    }\n    this.outByteCount += buf.length;\n    this.push(buf);\n    done();\n};\n"]},"metadata":{},"sourceType":"script"}